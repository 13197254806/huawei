# 华为软挑（复赛）思路

### 预处理

##### 1. 全局预处理

只在第0个时间片进行。自适应计算页大小，初始化页表、绑定关系。

##### 2. 时间段预处理

在每个时间段开头进行。根据后$R$个时间段各个类的读请求分布，计算类$i$和类$j$的相似度$sim[i][j]$（海明距离）。

##### 3. 时间片预处理

在每个时间片开头进行。用双端队列$unfinished$维护所有活跃的读请求，即将这一轮的新请求加入队尾，将失效的请求弹出。最后，遍历该队列，为磁盘的每个位置设置权重。

### 写操作

##### 1. 磁盘分页

把所有磁盘分页，确保每$3$个页中保存的数据时时刻刻一致。这$3$个页指向同一个绑定关系$binding$，每个$binding$又指向这$3$个页，但只在指向的第$1$个页中存放实际数据。规定每个对象的所有对象块存放在同一个页内，不允许分散在多个页内。

那么，本质不同的页只有$unique\_num=\frac{page\_num \times N}{3}$个。

##### 2. 页内分段

每个页内，将一段连续相同的数据块视作一个段，写入对象$obj$时按如下优先级：

- 如果写入$obj$能够降低某些段的$gap\_score$，那么选择降低$gap\_score$最多的空段写入
- 如果不能降低$gap\_score$，那么选择一个长度最大的空段写入
- 如果长度最大的空段

##### 3. 对象评分与写入

每个对象$obj$写入前，会遍历所有本质不同的页$page$，在每一个$page$中计算分数$gap\_score$。

```math
gap\_score(obj, page) =\min \{\sum_{c} (1-sim[obj.tag][page[c \pm 1].tag]) \}  \\
s.t. \ page[c]=0, c\in C, |C| = obj.size
```

选择一个$gap\_score$最小的页写入。

### 删操作

定位要删除的对象位置，维护相关数据结构。

### 读操作

##### 1. 动作选择策略

如果磁头当前位置的权重大于阈值且未被读过、未被加锁，则当前位置需要读，动作为$READ$，

如果磁头当前位置的权重小于阈值/已经度过/被加过锁，则该位置不用读，但仍需要选择是保持$READ$或是$PASS$（如果只因为当前位置不需要读就从$READ$切换为$PASS$，会导致下次$READ$的成本初始化为$64$，产生浪费）。策略是，根据磁头上次的动作和令牌消耗，自适应计算一个$window\_size$，并根据未来$window\_size$个位置的权重情况来做决定。（数学+贪心）

##### 2. 位置选择策略（主要优化点1）

利用滑动窗口，每个磁头都在当前磁盘上找到一个三元组$(start, end, K)$，代表预期要读的起始位置、结束位置、消耗的时间片数量。每$K$个时间片遵循先给区间$[start, end]$加锁，磁头读完$[start, end]$，最后给区间$[start, end]$解锁的范式。

##### 3. 上报策略（主要优化点2）

遍历当前$unfinished$队列中的每个读请求$request$，每个$request$对应一个要读的对象$obj$。

- 如果$obj$的每一个对象块都读取完成，则上报读成功，从$unfinished$中删掉$request$。
- 根据$obj$的$3$个副本所在磁盘的磁头位置、$obj$的存活时间等数据，计算一个期望分数$expected\_score(obj)$，如果$expected\_score(obj)\leq \tau$，则上报繁忙，从$unfinished$中删掉$request$。。
- 否则，保留$request$到下一轮。

### 垃圾回收

为了保证有绑定关系的$3$个页的数据时时刻刻相同，我们只允许在同一页内进行对象块的位置交换。

遍历页$page$内的每个位置$c_1$，找到一个位置$c_2 (c_2> c_1)$，使得交换这两个块之后预期产生的收益$profit(c_1, c_2)$最大。

```math
\begin{align*}
profit(c_1, r) &= [gap\_score(c_1) + gap\_score(r)] - [gap\_score'(c_1) + gap\_score'(r)] \\
&=sim[page[c_1].tag][page[c_1\pm 1].tag] + sim[page[r].tag][page[r\pm 1].tag] - \\
& \ \  \ \ \ sim[page[r].tag][page[c_1\pm 1].tag] - sim[page[c_1].tag][page[r\pm 1].tag]

\end{align*}
```

求$c_2$，满足:

```math
c_2 = \mathop{argmax} \limits_{r} \{profit(c_1, r) \} \\
s.t. \ profit(c_1, r) > \mu
```

如果能找到合适的$c_2$，则交换$c_1$和$c_2$

### TODO


